## 每日一练

### 1. 最有效率的方法算出2计算结果是8

#### 答案：

​	因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，最效率的方法是2 << 3。

### 2. switch语句能否作用在byte上，能否作用在long上，能否作用在String上? 

#### 答案：

​	在switch（expr1）中，expr1只能是一个整数表达式或者String或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long类型不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中。

### 3. char型变量中能不能存贮一个中文汉字?为什么? 

#### 答案：

​	char型变量是用来存储Unicode编码的字符的，unicode编码字符集中包含了汉字，所以，char型变量中当然可以存储汉字啦。不过，如果某个特殊的汉字没有被包含在unicode编码字符集中，那么，这个char型变量中就不能存储这个特殊汉字。补充说明：unicode编码占用两个字节，所以，char类型的变量也是占用两个字节。

### 4. 请说出作用域public，private，protected，以及不写时（default）的区别 

#### 答案：

​	public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包访问。

​	private：Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。

​	protected：介于public 和 private 之间的一种访问修饰符，一般称之为“保护访问权限”。被其修饰的属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。

​	default：即不加任何访问修饰符，通常称为“默认访问权限“或者“包访问权限”。该模式下，只允许在同一个包中进行访问。

​四种修饰符的访问权限范围：​​

| 访问修饰符 | 同一个类 | 同包 | 不同包，子类 | 不同包，非子类 |
| ---------- | -------- | ---- | ------------ | -------------- |
| private    | ✔        |      |              |                |
| default    | ✔        | ✔    |              |                |
| protected  | ✔        | ✔    | ✔            |                |
| public     | ✔        | ✔    | ✔            | ✔              |

### 5. 面向对象的特征有哪些

#### 答案：

1. 封装

2. 继承
3. 多态

### 6."=="和equals方法究竟有什么区别？

#### 答案：

​	“==”关系运算符是**专门用来比较两个变量之间的值是否相等**，对于基本数据类型就是比较栈中存储的数据的比较，如果是对象类型，比较的是存在栈内存中的指向对象的地址值。

​	equals方法是比较两个对象的内容是否相同，比如说字符串的比较就是使用equals方法，直接比较内容，如果使用“==”，比较的是地址值，对于两个对象那就永远是false。

==操作符专门用来比较两个变量的值是否相等，也就是用于比较变量所对应的内存中所存储的数值是否相同，要比较两个基本类型的数据或两个引用变量是否相等，只能用==操作符。
如果一个变量指向的数据是对象类型的，那么，这时候涉及了两块内存，对象本身占用一块内存（堆内存），变量也占用一块内存，例如Objet  obj  =  new  Object();变量obj是一个内存，new  Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量，如果要比较两个变量是否指向同一个对象，即要看这两个变量所对应的内存中的数值是否相等，这时候就需要用==操作符进行比较。
equals方法是用于比较两个独立对象的内容是否相同，就好比去比较两个人的长相是否相同，它比较的两个对象是独立的。例如，对于下面的代码：
String a=new String("foo");
String b=new String("foo");
两条new语句创建了两个对象，然后用a,b这两个变量分别指向了其中一个对象，这是两个不同的对象，它们的首地址是不同的，即a和b中存储的数值是不相同的，所以，表达式a==b将返回false，而这两个对象中的内容是相同的，所以，表达式a.equals(b)将返回true。
在实际开发中，我们经常要比较传递进行来的字符串内容是否等，例如，String  input  =  …;input.equals(“quit”)，许多人稍不注意就使用==进行比较了，这是错误的，随便从网上找几个项目实战的教学视频看看，里面就有大量这样的错误。记住，字符串的比较基本上都是使用equals方法。
如果一个类没有自己定义equals方法，那么它将继承Object类的equals方法，Object类的equals方法的实现代码如下：
boolean equals(Object o){
return this==o;
}
这说明，如果一个类没有自己定义equals方法，它默认的equals方法（从Object  类继承的）就是使用==操作符，也是在比较两个变量指向的对象是否是同一对象，这时候使用equals和使用==会得到同样的结果，如果比较的是两个独立的对象则总返回false。如果你编写的类希望能够比较该类创建的两个实例对象的内容是否相同，那么你必须覆盖equals方法，由你自己写代码来决定在什么情况即可认为两个对象的内容是相同的。

### 7. Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?

#### 答案：

- 重写(Override)规则：
  1. 参数列表必须完全与被重写方法的相同；
  2. 返回类型必须与被重写方法的返回类型相同；
  3. 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
  4. 父类的成员方法只能被它的子类重写；
  5. 声明为static和private的方法不能被重写。
- 重载(Overload)
  1. 方法名称相同，参数类型或参数长度不同，可以完成方法的重载。
  2. 方法的重载与返回值无关。


- 区别：

  1. 发生的位置不同

     ​	重载：一个类中

     ​	重写：子父类中

  2. 参数列表限制不同

     ​	重载：参数列表必须不同

     ​	重写：必须相同

  3. 返回值类型

     ​	重载：与返回值类型无关

     ​	重写：返回值类型必须一致

  4. 访问权限

     ​	重载:与访问权限无关

     ​	重写：子的方法权限 不能小于 父的方法权限

  5. 异常处理

     ​	重载：与异常无关

     ​	重写：异常范围可以更小，但是不能抛出新的异常。

### 8.fianl和finally的区别

#### 答案：

### 9. throw和throws的区别

#### 答案：

throw：
表示方法内抛出某种异常对象
如果异常对象是非 RuntimeException 则需要在方法申明时加上该异常的抛出 即需要加上 throws 语句 或者 在方法体内 try catch 处理该异常，否则编译报错
执行到 throw 语句则后面的语句块不再执行
throws：
方法的定义上使用 throws 表示这个方法可能抛出某种异常
需要由方法的调用者进行异常处理

### 10.List、Set、Map之间的区别？

#### 答案：

1、List、Set都是继承自Collection接口，Map则不是。
2、List特点：元素有放入顺序，元素可重复 ，
   Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是由该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。） 
3、Set和List对比： 
   Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。 
   List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。 
4、Map适合储存键值对的数据，它是由一系列键值对组成的集合，提供了key到Value的映射。