# 每日一练

## 1. HashMap和Hashtable的区别？

### 答案:

1. Hashtable继承Dictionary类，HashMap实现Map接口。


2. Hashtable线程安全，HashMap线程非安全。
3. Hashtable不允许null值，HashMap允许null值。

## 什么是Java序列化，什么情况下需要序列化？

### 答案：

序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。

以下情况需要使用 Java 序列化：

- 想把的内存中的对象状态保存到一个文件中或者数据库中时候；
- 想用套接字在网络上传送对象的时候；
- 想通过RMI（远程方法调用）传输对象的时候。

### HashMap的底层实现原理

1. HashMap是数组加链表的结构，当一个hashMap进行put操作时，先算出数组的下标，通过key的hashCode值(hashCode值是随机的)，对这个hashCode值进行‘位’运算（得出的角标一定是0---7，为什么数组长度必须是2的指数次幂，因为位运算必须是2的指数次幂才能得到角标在0--7），对数组大小进行取余，得出存入数组的哪个下标中。
2. 算出了插入哪个数组位置，当又有一个元素算出的下标位置在这个角标中时，利用链表结构了，新元素先插入头部，再把整个链表上的元素往下移动一格，数组中存的是一个entry的对象，其实也是entry的引用，当新元素插入时，把数组中的引用替换下，扩容是，先判断hashMap存的元素是否大于阈值（hashMap的大小*负载因子0.75），大于的话，需要扩容
3. 1.7的concurentHashMap中数组存的是一个叫Segment的类，这个类中有一个hashEntry的属性，分段锁
4. 1.8的hashMap是数组+链表+红黑树的结构，尾插法，插入值变成9个，当链表的值是大于8时，再链表变成红黑树，是不是大于8时就一定会转红黑树呢，不是的，先判断数组大小是否大于64，大于64才转，不大于先扩容。阈值是8，实际链表的长度是9.
5. hashMap为什么不安全？
   1. 数据丢失：多线程扩容的时候，数据丢失，resize（）
   2. 死锁：两个线程操作时，transfor方法中，会出现链表上的两个next相互指向，形成死链表

## 线程的生命周期和状态

### 答案：

1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
3. 阻塞(BLOCKED)：表示线程阻塞于锁。
4. 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5. 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
6. 终止(TERMINATED)：表示该线程已经执行完毕。

![线程生命周期](/images/线程生命周期.png)