# 每日一练

## 1. HashMap和Hashtable的区别？

### 答案:

1. Hashtable继承Dictionary类，HashMap实现Map接口。


2. Hashtable线程安全，HashMap线程非安全。
3. Hashtable不允许null值，HashMap允许null值。

## 2.什么是Java序列化，什么情况下需要序列化？

### 答案：

序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。

以下情况需要使用 Java 序列化：

- 想把的内存中的对象状态保存到一个文件中或者数据库中时候；
- 想用套接字在网络上传送对象的时候；
- 想通过RMI（远程方法调用）传输对象的时候。

## 3.HashMap的底层实现原理

### 答案：

1. HashMap是数组加链表的结构，当一个hashMap进行put操作时，先算出数组的下标，通过key的hashCode值(hashCode值是随机的)，对这个hashCode值进行‘位’运算（得出的角标一定是0---7，为什么数组长度必须是2的指数次幂，因为位运算必须是2的指数次幂才能得到角标在0--7），对数组大小进行取余，得出存入数组的哪个下标中。
2. 算出了插入哪个数组位置，当又有一个元素算出的下标位置在这个角标中时，利用链表结构了，新元素先插入头部，再把整个链表上的元素往下移动一格，数组中存的是一个entry的对象，其实也是entry的引用，当新元素插入时，把数组中的引用替换下，扩容是，先判断hashMap存的元素是否大于阈值（hashMap的大小*负载因子0.75），大于的话，需要扩容
3. 1.7的concurentHashMap中数组存的是一个叫Segment的类，这个类中有一个hashEntry的属性，分段锁
4. 1.8的hashMap是数组+链表+红黑树的结构，尾插法，插入值变成9个，当链表的值是大于8时，再链表变成红黑树，是不是大于8时就一定会转红黑树呢，不是的，先判断数组大小是否大于64，大于64才转，不大于先扩容。阈值是8，实际链表的长度是9.
5. hashMap为什么不安全？
   1. 数据丢失：多线程扩容的时候，数据丢失，resize（）
   2. 死锁：两个线程操作时，transfor方法中，会出现链表上的两个next相互指向，形成死链表

## 4.线程的生命周期和状态

### 答案：

1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。
线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。
3. 阻塞(BLOCKED)：表示线程阻塞于锁。
4. 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5. 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。
6. 终止(TERMINATED)：表示该线程已经执行完毕。

![线程生命周期](/images/线程生命周期.png)

## Runnable和Callable有什么区别?

### 答案：

1. 两者最大的不同点是：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；
2. Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；

## ThreadLocal是什么？有哪些使用场景？

### 答案：

TheardLocal是什么？

本地线程，只有自己能够访问到的线程。

具体含义：我们用ThreadLocal的时候里边设置的这个值是线程独有的，

线程独有的是什么意思呢?就是说这个线程里用到这个ThreadLocal的时候，

只有自己去往里设置，设置的是只有自己线程里才能访问到的Person,

而另外一个线程要访问的时候， 设置也是自己线程才能访问到的Person,这就是ThreadLocal的含义。

TheardLocal用途场景？

1.ThreadLocal 可以代替一些参数的传递.

2.spring的声明式事务解析，声明式事务一般是通过数据库，但是spring结合mybatis，我们是可以把整个事务写在配置文件中，

而这个配置文件里的事务，它实际上是管理了一系列的方法，方法1，方法2...如果每个方法都去连接池中拿数据库连接然后声

明式事务把这几个方法合在一起，视为一个完整的事务，拿到不同的对象，不能视为一个事务，所以将第一次执行时Connection

放到这个线程的本地对象Threadlocal里面，以后在那的时候就是直接在本地线程拿。

## Java多态的实现？

### 答案：

什么是多态？

接口的多种不同的实现方式即为多态。

多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术。

我们在程序中定义的引用变量所指向的具体类型和通过该引用变量的方法

调用在编程的时候并不确定，当处于运行期间才确定。就是这个引用变量

究竟指向哪一个实例对象，在编译期间是不确定的，只有运行期才能确定，

这样不用修改源码就可以把变量绑定到不同的类实例上，让程序拥有了多

个运行状态，这就是多态。

多态通常有两种实现方法：

1、子类继承父类（extends）

2、类实现接口（implements）

## Iterator与ListIterator有什么区别？

### 答案：

1. Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 
2. Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 
3. ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引


## 关于Float下面说法错误的是？

- Float是一个类
- Float在java.lang包中
- Float a = 1.0是正确的赋值方法（错误）
- Float a = new Float(1.0)是正确的赋值方法

Float = new Float(1.0); 这个的东西能存在，是因为Float类中有形参是float和double的两个构造器。
DoubIe d = new Double(1.0F) ； 这个能成立的原因是float 向上转型了。
FIoat a = 1.0 ； 这个东西不成立是因为浮点型的默认类型是double，而double不会自动转成float,然后再装箱。
Double d = 1.0f ；不成立的原因是因为Double类中的装箱方法，只有vaIueOf(String s) 和valueOf(double d) ；装箱本身可不会自动向上转型

## 怎么检测一个线程是否拥有锁？

### 答案：

在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。

## 怎么防止死锁?

### 答案：

死锁的四个必要条件：

- 互斥条件：线程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个线程所占有。此时若有其他线程请求该资源，则请求线程只能等待。

- 不剥夺条件：线程所获得的资源在未使用完毕之前，不能被其他线程强行夺走，即只能由获得该资源的线程自己主动释放。


- 请求和保持条件：线程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有，此时请求线程被阻塞，但对自己已获得的资源保持不放。


- 循环等待条件：存在一种线程资源的循环等待链，链中每一个线程已获得的资源同时被链中下一个线程所请求。即存在一个处于等待状态的线程集合{Pl, P2, ..., pn}，其中Pi等待的资源被P(i+1)占有（i=0, 1, ..., n-1)，Pn等待的资源被P0占有

避免死锁的方式：

- 加锁顺序（线程按照一定的顺序加锁）


- 加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）


- 死锁检测

## 数据库隔离级别有哪些，各自的含义是什么，MYSQL 默认的隔离级别是是什么？

```
1.未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
2.提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
3.可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
4.串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞
MYSQL默认是可重复读(RepeatedRead)级别
```

