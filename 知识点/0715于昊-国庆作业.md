## 一、简答题

### 1. Redis的持久化方式有哪些?各有何利弊?

1. RDB持久化
  RDB 是以二进制文件，是在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。Redis数据库RDB是默认开启的，可通过redis.conf配置参数。
  - **优点**：使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能。
  - **缺点**：RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。
2. AOF持久化
   AOF(Append-Only File)，将 “操作 + 数据” 以格式化指令的方式追加到操作日志文件的尾部，在 append 操作返回后(已经写入到文件或者将要写入)，才进行实际的数据变更，“日志文件”保存了历史所有的操作过程；当 server 需要数据恢复时，可以直接 replay 此日志文件，即可还原所有的操作过程。AOF 相对可靠，AOF 文件内容是字符串，非常容易阅读和解析。AOF 默认是关闭的，可以同构修改配置文件reds.conf：appendonly yes 开启。
   - **优点：**可以保持更高的数据完整性，如果设置追加 file 的时间是 1s，如果 redis 发生故障，最多会丢失1s 的数据；且如果日志写入不完整支持 redis-check-aof 来进行日志修复；AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）。
   - **缺点：**AOF 文件比 RDB 文件大，且恢复速度慢。

### 2. 说一下 mybatis 的一级缓存和二级缓存？

1. 一级缓存

   就是在SqlSession上的缓存，默认开启。

   在同一个SqlSession中，执行相同的SQL查询时；第一次会去查询数据库，并写在缓存中，第二次会直接从缓存中取。 当执行SQL时候两次查询中间发生了增删改的操作，则SQLSession的缓存会被清空。 每次查询会先去缓存中找，如果找不到，再去数据库查询，然后把结果写到缓存中。

2. 二级缓存

   就是在SqlSessionFactory上的缓存，可以实现多个SqlSession去操作同一个Mapper的sql语句，且多个SqlSession可以共用二级缓存。

   第一次调用mapper下的SQL去查询用户的信息，查询到的信息会存放代该mapper对应的二级缓存区域。 第二次调用namespace下的mapper映射文件中，相同的sql去查询用户信息，会去对应的二级缓存内取结果。

   ​

   **开启方式：**在映射文件中添加`<cache>`标签开启:

   ```xml
   <mapper>

       <cache></cache>
   </mapper>
   ```

### 3. 说一下 ACID 是什么？

- A

  **atomic，原子性**，要么都提交，要么都失败，不能一部分成功，一部分失败。

- C

  **consistent，一致性**，事物开始及结束后，数据的一致性约束没有被破坏

- I

  **isolation，隔离性**，并发事物间相互不影响，互不干扰。

- D

  **durability,持久性**，已经提交的事物对数据库所做的更新必须永久保存。即便发生崩溃，也不能被回滚或数据丢失。

### 4. 说一下 spring 的事务隔离？

| 事务隔离级别               | 说明                                                         | 级别 |
| -------------------------- | ------------------------------------------------------------ | :--: |
| ISOLATION_DEFAULT          | 默认隔离级别，同数据库隔离级别。                             |  -1  |
| ISOLATION_READ_UNCOMMITTED | 读未提交，允许读取未提交数据(会出现脏读、不可重复读、幻读)。 |  1   |
| ISOLATION_READ_COMMITTED   | 读已提交，允许从已经提交的并发事务读取(可防止脏读，但幻影读和不可重复读仍可能会发生)。 |  2   |
| ISOLATION_REPEATABLE_READ  | 可重复读，对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变(可防止脏读和不可重复读，但幻影读仍可能发生)。 |  4   |
| ISOLATION_SERIALIZABLE     | 串行化(顺序读)，顺序执行事务，隔离级别最高，效率最低(可防止脏读、不可重复读、幻读)。 |  8   |

### 5. 讲讲 Spring 事务的传播属性。

当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。

传播属性就是规定了事务方法和事务方法发生嵌套调用时事务如何进行传播。

spring定义了七种传播行为类型：

| 传播行为类型              | 说明                                                         |
| ------------------------- | ------------------------------------------------------------ |
| Propagation.REQUIRED      | 支持当前事务，如果当前有事务， 那么加入事务， 如果当前没有事务则新建一个(默认情况) |
| Propagation.NOT_SUPPORTED | 以非事务方式执行操作，如果当前存在事务就把当前事务挂起，执行完后恢复事务（忽略当前事务） |
| Propagation.SUPPORTS      | 如果当前有事务则加入，如果没有则不用事务                     |
| Propagation.MANDATORY     | 支持当前事务，如果当前没有事务，则抛出异常。                 |
| PROPAGATION_NEVER         | 以非事务方式执行，如果当前存在事务，则抛出异常。             |
| Propagation.REQUIRES_NEW  | 支持当前事务，如果当前有事务，则挂起当前事务，然后新创建一个事务，如果当前没有事务，则自己创建一个事务。 |
| Propagation.NESTED        | 如果当前存在事务，则嵌套在当前事务中。如果当前没有事务，则执行与Propagation.REQUIRED类似的操作 |

