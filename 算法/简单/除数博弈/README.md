# 除数博弈

​	爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 `N` 。在每个玩家的回合，玩家需要执行以下操作：

- 选出任一`x`，满足`0 < x < N`且`N % x == 0`。
- 用`N - x`替换黑板上的数字`N`。

如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 `True`，否则返回 `false`。假设两个玩家都以最佳状态参与游戏。

### 示例1：

```
输入：2
输出：true
解释：爱丽丝选择 1. 鲍勃无法进行操作
```

### 示例2：

```
输入：3
输出：false
解释：爱丽丝选择 1.鲍勃也选择 1.然后爱丽丝无法进行操作。
```

### 提示：

1.`1 <= N <= 1000`

### 思路1：找规律

- 当N = 1时，区间(0, 1)中没有整数是n的因数，故Alice败
- 当N = 2时，Alice只能选择1，N变为1，Bob无法进行操作，故Alice胜
- 当N = 3时，Alice只能选择1，N变为2，由上面N = 2的结果可知Alice败
- 当N = 4时，Alice只能选择1或2，如果Alice选择1，则N = 3，由N = 3的结果可知Alice胜，如果Alice选择2，则N = 2，Alice必败，由题意可知Alice不可能选择2
- 当N = 5时，Alice只能选择1，则N = 4，故Alice败
- ...

此时我们可以总结出规律：**N为奇数是先手者必败，N为偶数时先手者必胜**

**证明**

1. N = 1 和 N = 2时结论成立。

2. N > 2时，假设N <= k 时该结论成立，则 N = k + 1时：

   - 如果 k 为偶数，则 k + 1为奇数，x是 k + 1的因数，只可能是奇数，而奇数减去奇数等于偶数，且k + 1− x <= k，故轮到 Bob 的时候都是偶数。而根据我们的猜想假设 N <= k 的时候偶数的时候先手必胜，故此时无论 Alice 拿走什么，Bob 都会处于必胜态，所以 Alice 处于必败态。
   - 如果 k 为奇数，则 k + 1 为偶数，x可以是奇数也可以是偶数，若 Alice 减去一个奇数，那么 k + 1 - x 是一个小于等于 k 的奇数，此时 Bob 占有它，处于必败态，则 Alice 处于必胜态。

   综上所述，这个规律是正确的。

#### 代码

```java
class Solution {
    public boolean divisorGame(int N) {
        return N % 2 == 0;
    }
}
```

#### 复杂度分析

- 时间复杂度：$O(1)$
- 空间复杂度：$O(1)$

### 思路2：递归

在「思路一」中，我们写出了前面几项的答案，在这个过程中我们发现，Alice 处在$N = k$的状态时，他（她）做一步操作，必然使得 Bob 处于$N = m(m < k)$的状态。因此我们只要看是否存在一个 $m$是必败的状态，那么 Alice 直接执行对应的操作让当前的数字变成 $m$，Alice 就必胜了，如果没有任何一个是必败的状态的话，说明 Alice 无论怎么进行操作，最后都会让 Bob 处于必胜的状态，此时 Alice 是必败的。

结合以上我们定义$f[i]$表示当前数字$i$的时候先手是处于必胜态还是必败态，$true$表示先手必胜，$false$ 表示先手必败，从前往后递推，根据我们上文的分析，枚举$i$在 $(0, i)$中$i$的因数 $j$，看是否存在 $f[i-j]$ 为必败态即可。

#### 代码

```java
class Solution {
    public boolean divisorGame(int N) {
        boolean[] f = new boolean[N + 5];

        f[1] = false;
        f[2] = true;
        for (int i = 3; i <= N; ++i) {
            for (int j = 1; j < i; ++j) {
                if ((i % j) == 0 && !f[i - j]) {
                    f[i] = true;
                    break;
                }
            }
        }

        return f[N];
    }
}
```

#### 复杂度分析

- 时间复杂度：$O(n^2)$。递推的时候一共有n个状态要计算，每个状态需要$O(n)$的时间枚举因数，因此总时间复杂度为$O(n^2)$
- 空间复杂度：$O(n)$。我们需要$O(n)$的空间存储递推数组$f$的值。

### 思路3：动态规划

- 将所有的小于等于 N 的解都找出来，基于前面的，递推后面的。
- 状态转移: 如果 i 的约数里面有存在为 `False` 的（即输掉的情况），则当前 i 应为 `True`；如果没有，则为 `False`。

#### 代码

```java
class Solutuion {
    public boolean divisorGame(int N) {
        
    }
}
```



